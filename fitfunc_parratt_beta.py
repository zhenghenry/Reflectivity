#!/usr/bin/python3
#title           :fitfunc_parratt_beta.py
#description     :This is the function that calculates the specular reflectivity (and corresponding density profile) in an exact fashian via the Parrat formalism, including absorption
#author          : Michael Klimczak, Hans-Georg Steinrueck
#e-mail		 : michael.klimczak@fau.de, hgs@slac.stanford.edu
#date            :10/30/15
#version         :0.3
#usage           :
#notes           :Wavelength is still hard-coded
#			The code was cross-checked with genx, see 
# genx_rho_beta.dat
# genx_xrr.dat
# crossCheck_genx.pdf
# generated by running python genx_show.py crossCheck_genx.par
#python_version  :3.4.2 
#==============================================================================


import numpy as np
import scipy.special


def saveParams(paramsFile, params, header='# values \tlower \tupper', footer=''):

    output = np.column_stack(params)
    np.savetxt(paramsFile, output, header=header, footer=footer)

# wavelength in Angstrom
wavelength = 1.033

def reflectivity(q, params, isSLD=False):

    # make sure we have a numpy array
    params = np.array(params)

    # introduce constrained parameters
    params[params < 0] = params[-params[params < 0].astype(int)]

    # extract parameters
    I0, bkg = params[0:2]

    sig = params[4::4]

    rho = np.concatenate((np.ones(1) * params[2], params[5::4]))
    beta = np.concatenate((np.ones(1) * params[3], params[6::4]))
    d = np.concatenate((np.zeros(1), params[7::4]))

    numInterfaces = sig.shape[0]

    # create mesh of qs; one row per layer (including ambient/substrate), one column per q-value
# --> next line is new, to have qs complex
    qs = np.zeros((numInterfaces, q.shape[0]), dtype=np.complex64)

# --> this make the wrong critical angle correct, gets relative change in rho and beta right 
    beta-=beta[0]
    rho-=rho[0]

    qs = np.sqrt(np.subtract(*np.meshgrid((q**2), (8 * 2 * np.pi * 2.82e-5 * rho 	- 1j * 32 * 3.1415**2 * beta *0.00000001 / wavelength**2	))))	




    # create empty arrays of the right shape for r, p; one row per interface, one coulmn per q-value
    r = np.zeros((numInterfaces, q.shape[0]), dtype=np.complex64)
    p = np.copy(r)

    # calculate reflective indexes for each interface, phase terms for each layer
    for ii in np.arange(0, numInterfaces):
        #r[ii] = (qs[ii] - qs[ii+1]) / (qs[ii] + qs[ii+1]) * np.exp(-sig[ii]**2 * qs[ii]**2 / 2)
	# *****NEW***** ### qs[ii]* qs[ii+1] instead of qs[ii]**2: refraction corrected roughness; doesn't make a big difference
        r[ii] = (qs[ii] - qs[ii+1]) / (qs[ii] + qs[ii+1]) * np.exp(-sig[ii]**2 * qs[ii]* qs[ii+1] / 2)
        p[ii] = np.exp(1j * qs[ii] * d[ii])

    # recursively build the reflective index of the entire system from the bottom up
    rr = np.zeros((numInterfaces, q.shape[0]), dtype=np.complex64)

    rr = r[numInterfaces-1]


    for ii in np.arange(0, numInterfaces-1)[::-1]:
        rr = (r[ii] + rr * p[ii+1]) / (1 + r[ii] * rr * p[ii+1])
    #np.place(rr, np.isnan(rr), 1)
    if bkg == 0:
        return I0 * np.abs(rr)**2 #+ 1/10**(bkg)
    if bkg != 0:
        return I0 * np.abs(rr)**2 + 1/10**(bkg)

####################################################################################################
###calculate rho(z)
####################################################################################################
def density(z, params, roughness=True):

    # make sure we have a numpy array
    params = np.array(params)

    # introduce constrained parameters
    params[params < 0] = params[-params[params < 0].astype(int)]



    rho = np.concatenate((np.ones(1) * params[2], params[5::4]))

    sig = params[4::4]
    if not roughness:
        sig = 0 * sig + 0.0001

    d = np.concatenate((np.zeros(1), params[7::4]))
    Z = np.cumsum(d)

    numInterfaces = sig.shape[0]

    # sum up density contributions each layer
    density = z*0+rho[0]
    for ii in np.arange(0, numInterfaces):
        density += (rho[ii + 1] - rho[ii]) * (1 + scipy.special.erf((z-Z[ii]) / np.sqrt(2) / sig[ii])) / 2

    return density



####################################################################################################
###calculate beta(z)
####################################################################################################
def beta(z, params, roughness=True):

    # make sure we have a numpy array
    params = np.array(params)

    # introduce constrained parameters
    params[params < 0] = params[-params[params < 0].astype(int)]

    # extract parameters

    beta = np.concatenate((np.ones(1) * params[3], params[6::4]))

    sig = params[4::4]
    if not roughness:
        sig = 0 * sig + 0.0001

    d = np.concatenate((np.zeros(1), params[7::4]))
    Z = np.cumsum(d)

    numInterfaces = sig.shape[0]

    # sum up density contributions each layer
    beta_plot = z*0+beta[0]
    for ii in np.arange(0, numInterfaces):
        beta_plot += (beta[ii + 1] - beta[ii]) * (1 + scipy.special.erf((z-Z[ii]) / np.sqrt(2) / sig[ii])) / 2
    beta_plot *= 0.00000001


    return beta_plot
